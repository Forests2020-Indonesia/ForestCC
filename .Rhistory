# filter based on Z
print("Filter Z outlier")
las <- lasfilter(las, Z >= 0, Z <= 100)
}
# define preprocess function ----
preprocess <- function(chunk)
{
# read chunk ----
print("Read Las")
print(str(chunk))
strChunkFile <- strsplit(chunk@files, "/")[[1]][8]
if(!is.na(strChunkFile))
{
# if(strChunkFile == "example.laz")
# { print(strChunkFile)
print(strChunkFile)
return(NULL)
}
else
{
print(strChunkFile)
las <- readLAS(chunk)
if(is.empty(las)) return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
las <- lasfilter(las, !(Classification == 0 | Classification == 7))
# make dtm ----
print("create DTM and store at: ")
dtm <- mkDTM(las, chunk)
# normalize ----
print("Normalize...")
las <- lasnormalize(las, dtm)
# filter based on Z
print("Filter Z outlier")
las <- lasfilter(las, Z >= 0, Z <= 100)
}
}
}
# define preprocess function ----
preprocess <- function(chunk)
{
# read chunk ----
print("Read Las")
print(str(chunk))
strChunkFile <- strsplit(chunk@files, "/")[[1]][8]
if(!is.na(strChunkFile))
{
# if(strChunkFile == "example.laz")
# { print(strChunkFile)}
print(strChunkFile)
return(NULL)
}
else
{
print(strChunkFile)
las <- readLAS(chunk)
if(is.empty(las)) return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
las <- lasfilter(las, !(Classification == 0 | Classification == 7))
# make dtm ----
print("create DTM and store at: ")
dtm <- mkDTM(las, chunk)
# normalize ----
print("Normalize...")
las <- lasnormalize(las, dtm)
# filter based on Z
print("Filter Z outlier")
las <- lasfilter(las, Z >= 0, Z <= 100)
}
}
newctg = catalog_apply(ctg, preprocess)
l <- readLAS("PROCESSED_DATA/TEST_CTG_INS/LINE_8_1.las")
l <- readLAS("PROCESSED_DATA/TEST_CTG_INS/LINE_4_86.las")
l
ctg <- catalog("PROCESSED_DATA/TEST_CTG_INS/")
opt_chunk_buffer(ctg) <- 0
opt_chunk_size(ctg)   <- 0
opt_cores(ctg) <- 4
opt_output_files(ctg) <- "PROCESSED_DATA/SEL_PREPROCESS/{ORIGINALFILENAME}"
preprocess <- function(chunk)
{
l <- readLAS(chunk)
if(is.empty(l))
return NULL
print(chunk@files)
print("----------------------")
print(l)
l <- lasfilterduplicates(l)
}
preprocess <- function(chunk)
{
l <- readLAS(chunk)
if(is.empty(l))
return NULL
print(chunk@files)
print("----------------------")
print(l)
l <- lasfilterduplicates(l)
}
ls()
rm(l)
preprocess <- function(chunk)
{
l <- readLAS(chunk)
if(is.empty(l))
return NULL
print(chunk@files)
print("----------------------")
print(l)
l <- lasfilterduplicates(l)
}
preprocess <- function(chunk)
{
l <- readLAS(chunk)
if(is.empty(l))
return NULL
print(chunk@files)
print("----------------------")
print(l)
l <- lasfilterduplicates(l)
}
preprocess <- function(chunk)
{
l <- readLAS(chunk)
if(is.empty(l))
return(NULL)
print(chunk@files)
print("----------------------")
print(l)
l <- lasfilterduplicates(l)
}
new_ctg <- catalog_apply(ctg, preprocess)
library(lidR)
ctg <- catalog("PROCESSED_DATA/TEST_CTG_INS/")
opt_chunk_buffer(ctg) <- 0
opt_cores(ctg) <- 4
opt_chunk_size(ctg)   <- 0
opt_output_files(ctg) <- "PROCESSED_DATA/SEL_PREPROCESS/{ORIGINALFILENAME}"
preprocess <- function(chunk)
{
l <- readLAS(chunk)
print(str(chunk))
if(is.empty(l))
return(NULL)
print(chunk@files)
print("----------------------")
print(l)
l <- lasfilterduplicates(l)
}
new_ctg <- catalog_apply(ctg, preprocess)
preprocess <- function(chunk)
{
print(chunk@files)
print("----------------------")
l <- readLAS(chunk)
print(str(chunk))
if(is.empty(l))
return(NULL)
print(l)
l <- lasfilterduplicates(l)
print("***********************")
}
new_ctg <- catalog_apply(ctg, preprocess)
preprocess <- function(chunk)
{
print(chunk@files)
print("----------------------")
l <- readLAS(chunk)
print(str(chunk))
if(is.empty(l))
return(NULL)
print(l)
print("***********************")
l <- lasfilterduplicates(l)
}
new_ctg <- catalog_apply(ctg, preprocess)
rm(list=ls())
ctg <- catalog("PROCESSED_DATA/TEST_CTG_INS")
opt_chunk_buffer(ctg) <- 0
opt_chunk_size(ctg)   <- 0
opt_cores(ctg) <- 4
opt_output_files(ctg) <- "PROCESSED_DATA/SEL_PREPROCESS/{ORIGINALFILENAME}"
mkDTM <- function(las, chunk)
{
lst <- strsplit(chunk@save, "/")
fdtm <- paste0(gsub(lst[[1]][2], "SEL_DTM", chunk@save), ".tif")
print(fdtm)
# dtm
# 5- pts as an average of pts available in 9 grid of 1 m x 1m grid
tryCatch(dtm <- grid_terrain(las, res = 0.5, algorithm = kriging(k= 10L)),
error = function(cond) return(NULL))
if(!is.null(dtm))
{
crs(dtm) <- CRS("+init=epsg:32748")
writeRaster(dtm, filename=fdtm, overwrite=TRUE)
return(dtm)
}
}
# define preprocess function ----
preprocess <- function(chunk)
{
# read chunk ----
las <- readLAS(chunk)
if(is.empty(las))
return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
las <- lasfilter(las, !(Classification == 0 | Classification == 7))
# make dtm ----
print("create DTM and store at: ")
dtm <- mkDTM(las, chunk)
# normalize ----
print("Normalize...")
las <- lasnormalize(las, dtm)
# filter based on Z
print("Filter Z outlier")
las <- lasfilter(las, Z >= 0, Z <= 100)
}
# define preprocess function ----
preprocess <- function(chunk)
{
# read chunk ----
print("===============================")
print(str(chunk))
las <- readLAS(chunk)
if(is.empty(las))
return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
las <- lasfilter(las, !(Classification == 0 | Classification == 7))
# make dtm ----
print("create DTM and store at: ")
dtm <- mkDTM(las, chunk)
# normalize ----
print("Normalize...")
las <- lasnormalize(las, dtm)
# filter based on Z
print("Filter Z outlier")
las <- lasfilter(las, Z >= 0, Z <= 100)
}
newctg = catalog_apply(ctg, preprocess)
ctg <- catalog("PROCESSED_DATA/TEST_CTG_INS")
opt_chunk_buffer(ctg) <- 0
opt_chunk_size(ctg)   <- 0
opt_cores(ctg) <- 4
mkDTM <- function(las, chunk)
{
lst <- strsplit(chunk@save, "/")
fdtm <- paste0(gsub(lst[[1]][2], "SEL_DTM", chunk@save), ".tif")
print(fdtm)
# dtm
# 5- pts as an average of pts available in 9 grid of 1 m x 1m grid
tryCatch(dtm <- grid_terrain(las, res = 0.5, algorithm = kriging(k= 10L)),
error = function(cond) return(NULL))
if(!is.null(dtm))
{
crs(dtm) <- CRS("+init=epsg:32748")
writeRaster(dtm, filename=fdtm, overwrite=TRUE)
return(dtm)
}
}
opt_output_files(ctg) <- "PROCESSED_DATA/SEL_PREPROCESS/{ORIGINALFILENAME}"
# define preprocess function ----
preprocess <- function(chunk)
{
# read chunk ----
print("===============================")
print(str(chunk))
las <- readLAS(chunk)
if(is.empty(las))
return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
las <- lasfilter(las, !(Classification == 0 | Classification == 7))
# make dtm ----
print("create DTM and store at: ")
lst <- strsplit(chunk@save, "/")
fdtm <- paste0(gsub(lst[[1]][2], "SEL_DTM", chunk@save), ".tif")
print(fdtm)
# dtm
# 5- pts as an average of pts available in 9 grid of 1 m x 1m grid
tryCatch(dtm <- grid_terrain(las, res = 0.5, algorithm = kriging(k= 10L)),
error = function(cond) return(NULL))
if(!is.null(dtm))
{
crs(dtm) <- CRS("+init=epsg:32748")
writeRaster(dtm, filename=fdtm, overwrite=TRUE)
}
# normalize ----
print("Normalize...")
las <- lasnormalize(las, dtm)
# filter based on Z
print("Filter Z outlier")
las <- lasfilter(las, Z >= 0, Z <= 100)
}
newctg = catalog_apply(ctg, preprocess)
getwd()
ctg <- catalog("PROCESSED_DATA/TEST_CTG_INS")
opt_chunk_buffer(ctg) <- 0
opt_chunk_size(ctg)   <- 0
opt_cores(ctg) <- 4
opt_output_files(ctg) <- "PROCESSED_DATA/SEL_PREPROCESS/{ORIGINALFILENAME}"
newctg = catalog_apply(ctg, preprocess)
#   if(!is.null(dtm))
#   {
#     crs(dtm) <- CRS("+init=epsg:32748")
#     writeRaster(dtm, filename=fdtm, overwrite=TRUE)
#     return(dtm)
#   }
#
# }
#
# define preprocess function ----
preprocess <- function(chunk)
{
# read chunk ----
print("===============================")
print(str(chunk))
las <- readLAS(chunk)
if(is.empty(las))
return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
las <- lasfilter(las, !(Classification == 0 | Classification == 7))
# make dtm ----
print("create DTM and store at: ")
lst <- strsplit(chunk@save, "/")
fdtm <- paste0(gsub(lst[[1]][2], "SEL_DTM", chunk@save), ".tif")
print(fdtm)
# dtm
# 5- pts as an average of pts available in 9 grid of 1 m x 1m grid
tryCatch(dtm <- grid_terrain(las, res = 0.5, algorithm = kriging(k= 10L)),
error = function(cond) {
print("Bad LAS, can't make DTM")
return(NULL)
})
if(is.null(dtm))
return(NULL)
crs(dtm) <- CRS("+init=epsg:32748")
writeRaster(dtm, filename=fdtm, overwrite=TRUE)
# normalize ----
print("Normalize...")
las <- lasnormalize(las, dtm)
# filter based on Z
print("Filter Z outlier")
las <- lasfilter(las, Z >= 0, Z <= 100)
}
newctg = catalog_apply(ctg, preprocess)
rm(list=ls())
ctg <- catalog("PROCESSED_DATA/TEST_CTG_INS")
opt_chunk_buffer(ctg) <- 0
opt_chunk_size(ctg)   <- 0
opt_cores(ctg) <- 4
opt_output_files(ctg) <- "PROCESSED_DATA/SEL_PREPROCESS/{ORIGINALFILENAME}"
preprocess <- function(chunk)
{
# read chunk ----
print("===============================")
print(str(chunk))
las <- readLAS(chunk)
if(is.empty(las))
return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
las <- lasfilter(las, !(Classification == 0 | Classification == 7))
}
newctg = catalog_apply(ctg, preprocess)
preprocess <- function(chunk)
{
# read chunk ----
print("===============================")
print(str(chunk))
las <- readLAS(chunk)
if(is.empty(las))
return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
tryCtach(las <- lasfilter(las, !(Classification == 0 | Classification == 7)),
error = function(cond){
print("Bad LAS, can't filter the class")
return(NULL)
})
}
newctg = catalog_apply(ctg, preprocess)
preprocess <- function(chunk)
{
# read chunk ----
print("===============================")
print(str(chunk))
las <- readLAS(chunk)
if(is.empty(las))
return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
tryCatch(las <- lasfilter(las, !(Classification == 0 | Classification == 7)),
error = function(cond){
print("Bad LAS, can't filter the class")
return(NULL)
})
}
newctg = catalog_apply(ctg, preprocess)
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
preprocess <- function(chunk)
{
# read chunk ----
print("===============================")
print(str(chunk))
las <- readLAS(chunk)
if(is.empty(las))
return(NULL)
# filter duplicates X, Y, Z  ----
print("filtering X, Y, Z")
las <- lasfilterduplicates(las)
# filter duplicates X and Y ----
# it will retain only the first return
# to know behind this code line, check out lidR's R source at lascheck function
# this issue: https://github.com/Jean-Romain/lidR/issues/39
print("filtering X, Y")
las <- lasfilter(las, !duplicated(las@data, by=c("X", "Y")))
# remove unclassified points and low points ----
print("filtering Class = 0 and 7")
tryCatch(las <- lasfilter(las, !(Classification == 0 | Classification == 7)),
error = function(cond){
print("Bad LAS, can't filter the class")
NULL
})
}
newctg = catalog_apply(ctg, preprocess)
devtools::install_github("Jean-Romain/rlas")
